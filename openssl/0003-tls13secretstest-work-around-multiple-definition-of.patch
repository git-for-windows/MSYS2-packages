From a79291acdc20b3f1dc2b542e6058945ce887ce0f Mon Sep 17 00:00:00 2001
From: Johannes Schindelin <johannes.schindelin@gmx.de>
Date: Wed, 21 Nov 2018 17:53:41 +0100
Subject: [PATCH 3/3] tls13secretstest: work around "multiple definition of
 ..."

The way some functions are mocked does not find the favor of current
mingw-w64's ld.exe. So let's work around it by mocking them differently.

Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
---
 test/build.info         |  1 -
 test/tls13secretstest.c | 51 ++++++++++++++++++++++++++++-------------
 2 files changed, 35 insertions(+), 17 deletions(-)

diff --git a/test/build.info b/test/build.info
index f8b5085..d7f78eb 100644
--- a/test/build.info
+++ b/test/build.info
@@ -810,7 +810,6 @@ IF[{- !$disabled{tests} -}]
     PROGRAMS{noinst}=tls13secretstest
     SOURCE[tls13secretstest]=tls13secretstest.c
     DEFINE[tls13secretstest]=OPENSSL_NO_KTLS
-    SOURCE[tls13secretstest]= ../ssl/tls13_enc.c ../crypto/packet.c
     INCLUDE[tls13secretstest]=.. ../include ../apps/include
     DEPEND[tls13secretstest]=../libcrypto ../libssl libtestutil.a
   ENDIF
diff --git a/test/tls13secretstest.c b/test/tls13secretstest.c
index bf214d3..349c8bb 100644
--- a/test/tls13secretstest.c
+++ b/test/tls13secretstest.c
@@ -126,7 +126,8 @@ static unsigned char server_ats_iv[] = {
 };
 
 /* Mocked out implementations of various functions */
-int ssl3_digest_cached_records(SSL *s, int keep)
+#define ssl3_digest_cached_records mock_ssl3_digest_cached_records
+static int mock_ssl3_digest_cached_records(SSL *s, int keep)
 {
     return 1;
 }
@@ -134,7 +135,8 @@ int ssl3_digest_cached_records(SSL *s, int keep)
 static int full_hash = 0;
 
 /* Give a hash of the currently set handshake */
-int ssl_handshake_hash(SSL *s, unsigned char *out, size_t outlen,
+#define ssl_handshake_hash mock_ssl_handshake_hash
+static int mock_ssl_handshake_hash(SSL *s, unsigned char *out, size_t outlen,
                        size_t *hashlen)
 {
     if (sizeof(hs_start_hash) > outlen
@@ -152,26 +154,31 @@ int ssl_handshake_hash(SSL *s, unsigned char *out, size_t outlen,
     return 1;
 }
 
-const EVP_MD *ssl_handshake_md(SSL *s)
+#define ssl_handshake_md mock_ssl_handshake_md
+static const EVP_MD *mock_ssl_handshake_md(SSL *s)
 {
     return EVP_sha256();
 }
 
-void RECORD_LAYER_reset_read_sequence(RECORD_LAYER *rl)
+#define RECORD_LAYER_reset_read_sequence mock_RECORD_LAYER_reset_read_sequence
+static void mock_RECORD_LAYER_reset_read_sequence(RECORD_LAYER *rl)
 {
 }
 
-void RECORD_LAYER_reset_write_sequence(RECORD_LAYER *rl)
+#define RECORD_LAYER_reset_write_sequence mock_RECORD_LAYER_reset_write_sequence
+static void mock_RECORD_LAYER_reset_write_sequence(RECORD_LAYER *rl)
 {
 }
 
-int ssl_cipher_get_evp_cipher(SSL_CTX *ctx, const SSL_CIPHER *sslc,
+#define ssl_cipher_get_evp_cipher mock_ssl_cipher_get_evp_cipher
+int mock_ssl_cipher_get_evp_cipher(SSL_CTX *ctx, const SSL_CIPHER *sslc,
                                      const EVP_CIPHER **enc)
 {
     return 0;
 }
 
-int ssl_cipher_get_evp(SSL_CTX *ctx, const SSL_SESSION *s,
+#define ssl_cipher_get_evp mock_ssl_cipher_get_evp
+int mock_ssl_cipher_get_evp(SSL_CTX *ctx, const SSL_SESSION *s,
                        const EVP_CIPHER **enc, const EVP_MD **md,
                        int *mac_pkey_type, size_t *mac_secret_size,
                        SSL_COMP **comp, int use_etm)
@@ -180,12 +187,14 @@ int ssl_cipher_get_evp(SSL_CTX *ctx, const SSL_SESSION *s,
     return 0;
 }
 
-int tls1_alert_code(int code)
+#define tls1_alert_code mock_tls1_alert_code
+static int mock_tls1_alert_code(int code)
 {
     return code;
 }
 
-int ssl_log_secret(SSL *ssl,
+#define ssl_log_secret mock_ssl_log_secret
+static int mock_ssl_log_secret(SSL *ssl,
                    const char *label,
                    const uint8_t *secret,
                    size_t secret_len)
@@ -193,34 +202,41 @@ int ssl_log_secret(SSL *ssl,
     return 1;
 }
 
-const EVP_MD *ssl_md(SSL_CTX *ctx, int idx)
+#define ssl_md mock_ssl_md
+const EVP_MD *mock_ssl_md(SSL_CTX *ctx, int idx)
 {
     return EVP_sha256();
 }
 
-void ossl_statem_send_fatal(SSL *s, int al)
+#define ossl_statem_send_fatal mock_ossl_statem_send_fatal
+void mock_ossl_statem_send_fatal(SSL *s, int al)
 {
 }
 
-void ossl_statem_fatal(SSL *s, int al, int reason, const char *fmt, ...)
+#define ossl_statem_fatal mock_ossl_statem_fatal
+void mock_ossl_statem_fatal(SSL *s, int al, int reason, const char *fmt, ...)
 {
 }
 
-int ossl_statem_export_allowed(SSL *s)
+#define ossl_statem_export_allowed mock_ossl_statem_export_allowed
+static int mock_ossl_statem_export_allowed(SSL *s)
 {
     return 1;
 }
 
-int ossl_statem_export_early_allowed(SSL *s)
+#define ossl_statem_export_early_allowed mock_ossl_statem_export_early_allowed
+static int mock_ossl_statem_export_early_allowed(SSL *s)
 {
     return 1;
 }
 
-void ssl_evp_cipher_free(const EVP_CIPHER *cipher)
+#define ssl_evp_cipher_free mock_ssl_evp_cipher_free
+void mock_ssl_evp_cipher_free(const EVP_CIPHER *cipher)
 {
 }
 
-void ssl_evp_md_free(const EVP_MD *md)
+#define ssl_evp_md_free mock_ssl_evp_md_free
+void mock_ssl_evp_md_free(const EVP_MD *md)
 {
 }
 
@@ -406,3 +422,6 @@ int setup_tests(void)
     ADD_TEST(test_handshake_secrets);
     return 1;
 }
+
+#include "../ssl/tls13_enc.c"
+#include "../crypto/packet.c"
-- 
2.41.0

